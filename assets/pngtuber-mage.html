<!DOCTYPE html>
<html>
<head>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: transparent;
    width: 800px;
    height: 800px;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .mage-container {
    position: relative;
    width: 613px;
    height: 613px;
    transform-origin: center bottom;
  }

  .mage {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transform-origin: center bottom;
    filter: drop-shadow(0 0 12px rgba(138, 43, 226, 0.6));
    transition: transform 0.05s ease-out, filter 0.1s ease-out;
  }

  /* Idle state - gentle breathing */
  .mage.idle {
    animation: breathe 3s ease-in-out infinite;
  }

  @keyframes breathe {
    0%, 100% { transform: scaleY(1) translateY(0); }
    50% { transform: scaleY(1.02) translateY(-3px); }
  }

  /* Speaking state - bouncy reaction */
  .mage.speaking {
    animation: none;
  }

  /* Glow overlay for when speaking */
  .glow-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(138, 43, 226, 0.3) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.1s ease-out;
    pointer-events: none;
  }

  /* Status indicator */
  .status {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-family: monospace;
    font-size: 14px;
    color: #888;
    background: rgba(0,0,0,0.5);
    padding: 4px 8px;
    border-radius: 4px;
    opacity: 0.7;
  }

  .status.error { color: #ff6666; }
  .status.listening { color: #66ff66; }

  /* Magic particles when speaking */
  .magic-particle {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #aa44ff;
    pointer-events: none;
    animation: particleFloat 1s ease-out forwards;
  }

  @keyframes particleFloat {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-80px) scale(0); }
  }
</style>
</head>
<body>

<div class="mage-container" id="container">
  <img class="mage idle" id="mage" src="redblackmage-transparent.png" alt="Mage">
  <div class="glow-overlay" id="glow"></div>
</div>
<div class="status" id="status">Connecting...</div>

<script>
const mage = document.getElementById('mage');
const glow = document.getElementById('glow');
const container = document.getElementById('container');
const status = document.getElementById('status');

let isSpeaking = false;
let speakingTimeout = null;

// Sensitivity settings
const VOLUME_THRESHOLD = 5;   // Minimum volume to trigger speaking
const SPEAKING_HOLD_MS = 150; // How long to hold speaking state after sound stops

function createParticle() {
  const particle = document.createElement('div');
  particle.className = 'magic-particle';
  particle.style.left = (Math.random() * 500 + 50) + 'px';
  particle.style.top = (Math.random() * 200 + 300) + 'px';
  particle.style.background = `hsl(${270 + Math.random() * 40}, 80%, 60%)`;
  container.appendChild(particle);
  setTimeout(() => particle.remove(), 1000);
}

function updateMage(volume) {
  // Normalize volume (0-100 scale)
  const normalizedVolume = Math.min(volume / 50, 1);

  if (volume > VOLUME_THRESHOLD) {
    // Speaking!
    if (!isSpeaking) {
      isSpeaking = true;
      mage.classList.remove('idle');
      mage.classList.add('speaking');
    }

    // Clear any pending timeout
    if (speakingTimeout) {
      clearTimeout(speakingTimeout);
      speakingTimeout = null;
    }

    // Dynamic transform based on volume
    const bounce = Math.sin(Date.now() / 50) * (5 + normalizedVolume * 10);
    const scale = 1 + normalizedVolume * 0.08;
    const squash = 1 - normalizedVolume * 0.05;

    mage.style.transform = `translateY(${-bounce}px) scaleX(${scale}) scaleY(${squash * scale})`;

    // Glow intensity based on volume
    glow.style.opacity = normalizedVolume * 0.8;

    // Enhanced drop shadow when speaking
    const glowIntensity = 12 + normalizedVolume * 30;
    mage.style.filter = `drop-shadow(0 0 ${glowIntensity}px rgba(138, 43, 226, ${0.6 + normalizedVolume * 0.4}))`;

    // Spawn particles occasionally when loud
    if (Math.random() < normalizedVolume * 0.3) {
      createParticle();
    }

  } else {
    // Not speaking - but use a timeout to avoid flickering
    if (isSpeaking && !speakingTimeout) {
      speakingTimeout = setTimeout(() => {
        isSpeaking = false;
        mage.classList.remove('speaking');
        mage.classList.add('idle');
        mage.style.transform = '';
        mage.style.filter = 'drop-shadow(0 0 12px rgba(138, 43, 226, 0.6))';
        glow.style.opacity = 0;
        speakingTimeout = null;
      }, SPEAKING_HOLD_MS);
    }
  }
}

// Poll audio levels from file
async function pollAudioLevels() {
  try {
    const response = await fetch('audio-levels.json?' + Date.now());
    const data = await response.json();
    updateMage(data.volume || 0);

    // Update status on first success
    if (status.style.display !== 'none') {
      status.textContent = 'Connected!';
      status.className = 'status listening';
      setTimeout(() => {
        status.style.display = 'none';
      }, 1500);
    }
  } catch (err) {
    // File not being updated yet
    if (status.style.display !== 'none') {
      status.textContent = 'Run audio-monitor.py';
      status.className = 'status error';
    }
  }

  // Poll at ~30fps
  setTimeout(pollAudioLevels, 33);
}

// Start polling
pollAudioLevels();
</script>
</body>
</html>
